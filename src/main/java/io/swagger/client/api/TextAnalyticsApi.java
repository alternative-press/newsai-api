/*
 * Event Registry REST API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 8.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.api;

import io.swagger.client.ApiCallback;
import io.swagger.client.ApiClient;
import io.swagger.client.ApiException;
import io.swagger.client.ApiResponse;
import io.swagger.client.Configuration;
import io.swagger.client.Pair;
import io.swagger.client.ProgressRequestBody;
import io.swagger.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import io.swagger.client.model.Annotation;
import io.swagger.client.model.Categorization;
import io.swagger.client.model.DetectLanguage;
import io.swagger.client.model.ExtractArticleInfo;
import io.swagger.client.model.InlineResponse200;
import io.swagger.client.model.InlineResponse2001;
import io.swagger.client.model.Sentiment;
import io.swagger.client.model.Similarity;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class TextAnalyticsApi {
    private ApiClient apiClient;

    public TextAnalyticsApi() {
        this(Configuration.getDefaultApiClient());
    }

    public TextAnalyticsApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /**
     * Build call for annotate
     * @param apiKey Your API key (required)
     * @param text Define a text that you&#x27;ll like to see annotated. (required)
     * @param minLinkFrequency The minimum number of times the phrase should appear in the link in order for use to use it as a candidate for the &lt;a href&#x3D;\&quot;#\&quot;&gt;annotation&lt;/a&gt;. (optional, default to 3)
     * @param minLinkRelFrequency Consider the candidate only if the given text points to the candidate with probability above this value. Value between 0 and 1. (optional, default to 0.01)
     * @param nWordsToIgnoreFromList Use this setting to ignore common phrases. If a phrase consists entirely of very frequent words, it will be ignore. A word is considered frequent if it is one of the most frequent words (in terms of document frequency) in the Wikipedia of the corresponding language. If 0 it will disable this heuristic. (optional, default to 200)
     * @param minPMentionGivenPhrase &#x27;Probability that the given phrase, if found on Wikipedia, is annotated with the concept. If non-zero, it can help to remove the common words.&#x27; (optional, default to 0.03)
     * @param pageRankSqThreshold &#x27;Probability that the given phrase, if found on Wikipedia, is annotated with the concept. If non-zero, it can help to remove the common words.&#x27; (optional, default to 0.95)
     * @param applyPageRankSqThreshold &#x27;Apply pageRankSqThreshold to the requested response.&#x27; (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call annotateCall(String apiKey, String text, Integer minLinkFrequency, Double minLinkRelFrequency, Integer nWordsToIgnoreFromList, Double minPMentionGivenPhrase, Double pageRankSqThreshold, Boolean applyPageRankSqThreshold, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/annotate";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (apiKey != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("apiKey", apiKey));
        if (text != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("text", text));
        if (minLinkFrequency != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("minLinkFrequency", minLinkFrequency));
        if (minLinkRelFrequency != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("minLinkRelFrequency", minLinkRelFrequency));
        if (nWordsToIgnoreFromList != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("nWordsToIgnoreFromList", nWordsToIgnoreFromList));
        if (minPMentionGivenPhrase != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("minPMentionGivenPhrase", minPMentionGivenPhrase));
        if (pageRankSqThreshold != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("pageRankSqThreshold", pageRankSqThreshold));
        if (applyPageRankSqThreshold != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("applyPageRankSqThreshold", applyPageRankSqThreshold));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call annotateValidateBeforeCall(String apiKey, String text, Integer minLinkFrequency, Double minLinkRelFrequency, Integer nWordsToIgnoreFromList, Double minPMentionGivenPhrase, Double pageRankSqThreshold, Boolean applyPageRankSqThreshold, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'apiKey' is set
        if (apiKey == null) {
            throw new ApiException("Missing the required parameter 'apiKey' when calling annotate(Async)");
        }
        // verify the required parameter 'text' is set
        if (text == null) {
            throw new ApiException("Missing the required parameter 'text' when calling annotate(Async)");
        }
        
        com.squareup.okhttp.Call call = annotateCall(apiKey, text, minLinkFrequency, minLinkRelFrequency, nWordsToIgnoreFromList, minPMentionGivenPhrase, pageRankSqThreshold, applyPageRankSqThreshold, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * identify people, locations, organizations and things mentioned in the document
     * The endpoint is able to semantically annotate the provided document. The semantic annotation includes identification of people, locations, organizations and things mentioned in the document. The annotations all have a unique URI that is a url to the Wikipedia page for the concept. 
     * @param apiKey Your API key (required)
     * @param text Define a text that you&#x27;ll like to see annotated. (required)
     * @param minLinkFrequency The minimum number of times the phrase should appear in the link in order for use to use it as a candidate for the &lt;a href&#x3D;\&quot;#\&quot;&gt;annotation&lt;/a&gt;. (optional, default to 3)
     * @param minLinkRelFrequency Consider the candidate only if the given text points to the candidate with probability above this value. Value between 0 and 1. (optional, default to 0.01)
     * @param nWordsToIgnoreFromList Use this setting to ignore common phrases. If a phrase consists entirely of very frequent words, it will be ignore. A word is considered frequent if it is one of the most frequent words (in terms of document frequency) in the Wikipedia of the corresponding language. If 0 it will disable this heuristic. (optional, default to 200)
     * @param minPMentionGivenPhrase &#x27;Probability that the given phrase, if found on Wikipedia, is annotated with the concept. If non-zero, it can help to remove the common words.&#x27; (optional, default to 0.03)
     * @param pageRankSqThreshold &#x27;Probability that the given phrase, if found on Wikipedia, is annotated with the concept. If non-zero, it can help to remove the common words.&#x27; (optional, default to 0.95)
     * @param applyPageRankSqThreshold &#x27;Apply pageRankSqThreshold to the requested response.&#x27; (optional)
     * @return Annotation
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public Annotation annotate(String apiKey, String text, Integer minLinkFrequency, Double minLinkRelFrequency, Integer nWordsToIgnoreFromList, Double minPMentionGivenPhrase, Double pageRankSqThreshold, Boolean applyPageRankSqThreshold) throws ApiException {
        ApiResponse<Annotation> resp = annotateWithHttpInfo(apiKey, text, minLinkFrequency, minLinkRelFrequency, nWordsToIgnoreFromList, minPMentionGivenPhrase, pageRankSqThreshold, applyPageRankSqThreshold);
        return resp.getData();
    }

    /**
     * identify people, locations, organizations and things mentioned in the document
     * The endpoint is able to semantically annotate the provided document. The semantic annotation includes identification of people, locations, organizations and things mentioned in the document. The annotations all have a unique URI that is a url to the Wikipedia page for the concept. 
     * @param apiKey Your API key (required)
     * @param text Define a text that you&#x27;ll like to see annotated. (required)
     * @param minLinkFrequency The minimum number of times the phrase should appear in the link in order for use to use it as a candidate for the &lt;a href&#x3D;\&quot;#\&quot;&gt;annotation&lt;/a&gt;. (optional, default to 3)
     * @param minLinkRelFrequency Consider the candidate only if the given text points to the candidate with probability above this value. Value between 0 and 1. (optional, default to 0.01)
     * @param nWordsToIgnoreFromList Use this setting to ignore common phrases. If a phrase consists entirely of very frequent words, it will be ignore. A word is considered frequent if it is one of the most frequent words (in terms of document frequency) in the Wikipedia of the corresponding language. If 0 it will disable this heuristic. (optional, default to 200)
     * @param minPMentionGivenPhrase &#x27;Probability that the given phrase, if found on Wikipedia, is annotated with the concept. If non-zero, it can help to remove the common words.&#x27; (optional, default to 0.03)
     * @param pageRankSqThreshold &#x27;Probability that the given phrase, if found on Wikipedia, is annotated with the concept. If non-zero, it can help to remove the common words.&#x27; (optional, default to 0.95)
     * @param applyPageRankSqThreshold &#x27;Apply pageRankSqThreshold to the requested response.&#x27; (optional)
     * @return ApiResponse&lt;Annotation&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Annotation> annotateWithHttpInfo(String apiKey, String text, Integer minLinkFrequency, Double minLinkRelFrequency, Integer nWordsToIgnoreFromList, Double minPMentionGivenPhrase, Double pageRankSqThreshold, Boolean applyPageRankSqThreshold) throws ApiException {
        com.squareup.okhttp.Call call = annotateValidateBeforeCall(apiKey, text, minLinkFrequency, minLinkRelFrequency, nWordsToIgnoreFromList, minPMentionGivenPhrase, pageRankSqThreshold, applyPageRankSqThreshold, null, null);
        Type localVarReturnType = new TypeToken<Annotation>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * identify people, locations, organizations and things mentioned in the document (asynchronously)
     * The endpoint is able to semantically annotate the provided document. The semantic annotation includes identification of people, locations, organizations and things mentioned in the document. The annotations all have a unique URI that is a url to the Wikipedia page for the concept. 
     * @param apiKey Your API key (required)
     * @param text Define a text that you&#x27;ll like to see annotated. (required)
     * @param minLinkFrequency The minimum number of times the phrase should appear in the link in order for use to use it as a candidate for the &lt;a href&#x3D;\&quot;#\&quot;&gt;annotation&lt;/a&gt;. (optional, default to 3)
     * @param minLinkRelFrequency Consider the candidate only if the given text points to the candidate with probability above this value. Value between 0 and 1. (optional, default to 0.01)
     * @param nWordsToIgnoreFromList Use this setting to ignore common phrases. If a phrase consists entirely of very frequent words, it will be ignore. A word is considered frequent if it is one of the most frequent words (in terms of document frequency) in the Wikipedia of the corresponding language. If 0 it will disable this heuristic. (optional, default to 200)
     * @param minPMentionGivenPhrase &#x27;Probability that the given phrase, if found on Wikipedia, is annotated with the concept. If non-zero, it can help to remove the common words.&#x27; (optional, default to 0.03)
     * @param pageRankSqThreshold &#x27;Probability that the given phrase, if found on Wikipedia, is annotated with the concept. If non-zero, it can help to remove the common words.&#x27; (optional, default to 0.95)
     * @param applyPageRankSqThreshold &#x27;Apply pageRankSqThreshold to the requested response.&#x27; (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call annotateAsync(String apiKey, String text, Integer minLinkFrequency, Double minLinkRelFrequency, Integer nWordsToIgnoreFromList, Double minPMentionGivenPhrase, Double pageRankSqThreshold, Boolean applyPageRankSqThreshold, final ApiCallback<Annotation> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = annotateValidateBeforeCall(apiKey, text, minLinkFrequency, minLinkRelFrequency, nWordsToIgnoreFromList, minPMentionGivenPhrase, pageRankSqThreshold, applyPageRankSqThreshold, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<Annotation>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for categorize
     * @param apiKey Your API key (required)
     * @param text Define a text that you&#x27;ll like to see categorized. (required)
     * @param taxonomy Define the taxonomy in which you&#x27;ll want to categorize the selected text (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call categorizeCall(String apiKey, String text, String taxonomy, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/categorize";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (apiKey != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("apiKey", apiKey));
        if (text != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("text", text));
        if (taxonomy != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("taxonomy", taxonomy));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call categorizeValidateBeforeCall(String apiKey, String text, String taxonomy, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'apiKey' is set
        if (apiKey == null) {
            throw new ApiException("Missing the required parameter 'apiKey' when calling categorize(Async)");
        }
        // verify the required parameter 'text' is set
        if (text == null) {
            throw new ApiException("Missing the required parameter 'text' when calling categorize(Async)");
        }
        // verify the required parameter 'taxonomy' is set
        if (taxonomy == null) {
            throw new ApiException("Missing the required parameter 'taxonomy' when calling categorize(Async)");
        }
        
        com.squareup.okhttp.Call call = categorizeCall(apiKey, text, taxonomy, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Categorize the content into a set of predefined categories
     * The categorization of your content into a predefined set of categories. The &#x60;dmoz&#x60; taxonomy contains over 5000 categories and can only be used for documents in English languge. The &#x60;news&#x60; taxonomy contains only 8 top level categories commonly used to categorize the news content, but can be applied for any language. The categorization into both taxonomies can work well only on documents of decent size (like news articles). 
     * @param apiKey Your API key (required)
     * @param text Define a text that you&#x27;ll like to see categorized. (required)
     * @param taxonomy Define the taxonomy in which you&#x27;ll want to categorize the selected text (required)
     * @return Categorization
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public Categorization categorize(String apiKey, String text, String taxonomy) throws ApiException {
        ApiResponse<Categorization> resp = categorizeWithHttpInfo(apiKey, text, taxonomy);
        return resp.getData();
    }

    /**
     * Categorize the content into a set of predefined categories
     * The categorization of your content into a predefined set of categories. The &#x60;dmoz&#x60; taxonomy contains over 5000 categories and can only be used for documents in English languge. The &#x60;news&#x60; taxonomy contains only 8 top level categories commonly used to categorize the news content, but can be applied for any language. The categorization into both taxonomies can work well only on documents of decent size (like news articles). 
     * @param apiKey Your API key (required)
     * @param text Define a text that you&#x27;ll like to see categorized. (required)
     * @param taxonomy Define the taxonomy in which you&#x27;ll want to categorize the selected text (required)
     * @return ApiResponse&lt;Categorization&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Categorization> categorizeWithHttpInfo(String apiKey, String text, String taxonomy) throws ApiException {
        com.squareup.okhttp.Call call = categorizeValidateBeforeCall(apiKey, text, taxonomy, null, null);
        Type localVarReturnType = new TypeToken<Categorization>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Categorize the content into a set of predefined categories (asynchronously)
     * The categorization of your content into a predefined set of categories. The &#x60;dmoz&#x60; taxonomy contains over 5000 categories and can only be used for documents in English languge. The &#x60;news&#x60; taxonomy contains only 8 top level categories commonly used to categorize the news content, but can be applied for any language. The categorization into both taxonomies can work well only on documents of decent size (like news articles). 
     * @param apiKey Your API key (required)
     * @param text Define a text that you&#x27;ll like to see categorized. (required)
     * @param taxonomy Define the taxonomy in which you&#x27;ll want to categorize the selected text (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call categorizeAsync(String apiKey, String text, String taxonomy, final ApiCallback<Categorization> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = categorizeValidateBeforeCall(apiKey, text, taxonomy, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<Categorization>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for detectLanguage
     * @param apiKey Your API key (required)
     * @param text Define a text that&#x27;ll be used to detect the language in which it&#x27;s written. (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call detectLanguageCall(String apiKey, String text, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/detectLanguage";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (apiKey != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("apiKey", apiKey));
        if (text != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("text", text));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call detectLanguageValidateBeforeCall(String apiKey, String text, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'apiKey' is set
        if (apiKey == null) {
            throw new ApiException("Missing the required parameter 'apiKey' when calling detectLanguage(Async)");
        }
        // verify the required parameter 'text' is set
        if (text == null) {
            throw new ApiException("Missing the required parameter 'text' when calling detectLanguage(Async)");
        }
        
        com.squareup.okhttp.Call call = detectLanguageCall(apiKey, text, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Detect the language of the input text
     * 
     * @param apiKey Your API key (required)
     * @param text Define a text that&#x27;ll be used to detect the language in which it&#x27;s written. (required)
     * @return DetectLanguage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public DetectLanguage detectLanguage(String apiKey, String text) throws ApiException {
        ApiResponse<DetectLanguage> resp = detectLanguageWithHttpInfo(apiKey, text);
        return resp.getData();
    }

    /**
     * Detect the language of the input text
     * 
     * @param apiKey Your API key (required)
     * @param text Define a text that&#x27;ll be used to detect the language in which it&#x27;s written. (required)
     * @return ApiResponse&lt;DetectLanguage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<DetectLanguage> detectLanguageWithHttpInfo(String apiKey, String text) throws ApiException {
        com.squareup.okhttp.Call call = detectLanguageValidateBeforeCall(apiKey, text, null, null);
        Type localVarReturnType = new TypeToken<DetectLanguage>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Detect the language of the input text (asynchronously)
     * 
     * @param apiKey Your API key (required)
     * @param text Define a text that&#x27;ll be used to detect the language in which it&#x27;s written. (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call detectLanguageAsync(String apiKey, String text, final ApiCallback<DetectLanguage> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = detectLanguageValidateBeforeCall(apiKey, text, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<DetectLanguage>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for extractArticleInfo
     * @param apiKey Your API key (required)
     * @param url Define an article URL, that&#x27;ll be used to extract the article information. (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call extractArticleInfoCall(String apiKey, String url, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/extractArticleInfo";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (apiKey != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("apiKey", apiKey));
        if (url != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("url", url));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call extractArticleInfoValidateBeforeCall(String apiKey, String url, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'apiKey' is set
        if (apiKey == null) {
            throw new ApiException("Missing the required parameter 'apiKey' when calling extractArticleInfo(Async)");
        }
        // verify the required parameter 'url' is set
        if (url == null) {
            throw new ApiException("Missing the required parameter 'url' when calling extractArticleInfo(Async)");
        }
        
        com.squareup.okhttp.Call call = extractArticleInfoCall(apiKey, url, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Extract article information (title, body, authors, ...) from article URL
     * 
     * @param apiKey Your API key (required)
     * @param url Define an article URL, that&#x27;ll be used to extract the article information. (required)
     * @return ExtractArticleInfo
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ExtractArticleInfo extractArticleInfo(String apiKey, String url) throws ApiException {
        ApiResponse<ExtractArticleInfo> resp = extractArticleInfoWithHttpInfo(apiKey, url);
        return resp.getData();
    }

    /**
     * Extract article information (title, body, authors, ...) from article URL
     * 
     * @param apiKey Your API key (required)
     * @param url Define an article URL, that&#x27;ll be used to extract the article information. (required)
     * @return ApiResponse&lt;ExtractArticleInfo&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ExtractArticleInfo> extractArticleInfoWithHttpInfo(String apiKey, String url) throws ApiException {
        com.squareup.okhttp.Call call = extractArticleInfoValidateBeforeCall(apiKey, url, null, null);
        Type localVarReturnType = new TypeToken<ExtractArticleInfo>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Extract article information (title, body, authors, ...) from article URL (asynchronously)
     * 
     * @param apiKey Your API key (required)
     * @param url Define an article URL, that&#x27;ll be used to extract the article information. (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call extractArticleInfoAsync(String apiKey, String url, final ApiCallback<ExtractArticleInfo> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = extractArticleInfoValidateBeforeCall(apiKey, url, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ExtractArticleInfo>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for semanticSimilarity
     * @param apiKey Your API key (required)
     * @param text1 The first text that&#x27;ll be used in the comparison. (required)
     * @param text2 The second text that&#x27;ll be used in the comparison. (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call semanticSimilarityCall(String apiKey, String text1, String text2, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/semanticSimilarity";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (apiKey != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("apiKey", apiKey));
        if (text1 != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("text1", text1));
        if (text2 != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("text2", text2));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call semanticSimilarityValidateBeforeCall(String apiKey, String text1, String text2, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'apiKey' is set
        if (apiKey == null) {
            throw new ApiException("Missing the required parameter 'apiKey' when calling semanticSimilarity(Async)");
        }
        // verify the required parameter 'text1' is set
        if (text1 == null) {
            throw new ApiException("Missing the required parameter 'text1' when calling semanticSimilarity(Async)");
        }
        // verify the required parameter 'text2' is set
        if (text2 == null) {
            throw new ApiException("Missing the required parameter 'text2' when calling semanticSimilarity(Async)");
        }
        
        com.squareup.okhttp.Call call = semanticSimilarityCall(apiKey, text1, text2, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Compute semantic similarity of two documents, potentially in different languages
     * This API endpoint allows you to compare two documents, potentially in different languages, and compute the semantic similarity between them.
     * @param apiKey Your API key (required)
     * @param text1 The first text that&#x27;ll be used in the comparison. (required)
     * @param text2 The second text that&#x27;ll be used in the comparison. (required)
     * @return Similarity
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public Similarity semanticSimilarity(String apiKey, String text1, String text2) throws ApiException {
        ApiResponse<Similarity> resp = semanticSimilarityWithHttpInfo(apiKey, text1, text2);
        return resp.getData();
    }

    /**
     * Compute semantic similarity of two documents, potentially in different languages
     * This API endpoint allows you to compare two documents, potentially in different languages, and compute the semantic similarity between them.
     * @param apiKey Your API key (required)
     * @param text1 The first text that&#x27;ll be used in the comparison. (required)
     * @param text2 The second text that&#x27;ll be used in the comparison. (required)
     * @return ApiResponse&lt;Similarity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Similarity> semanticSimilarityWithHttpInfo(String apiKey, String text1, String text2) throws ApiException {
        com.squareup.okhttp.Call call = semanticSimilarityValidateBeforeCall(apiKey, text1, text2, null, null);
        Type localVarReturnType = new TypeToken<Similarity>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Compute semantic similarity of two documents, potentially in different languages (asynchronously)
     * This API endpoint allows you to compare two documents, potentially in different languages, and compute the semantic similarity between them.
     * @param apiKey Your API key (required)
     * @param text1 The first text that&#x27;ll be used in the comparison. (required)
     * @param text2 The second text that&#x27;ll be used in the comparison. (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call semanticSimilarityAsync(String apiKey, String text1, String text2, final ApiCallback<Similarity> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = semanticSimilarityValidateBeforeCall(apiKey, text1, text2, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<Similarity>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for sentiment
     * @param apiKey Your API key (required)
     * @param text The text that will be used to calculate sentiment. (required)
     * @param sentences Number of sentences on which to compute the sentiment. (optional, default to 10)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call sentimentCall(String apiKey, String text, Integer sentences, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/sentiment";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (apiKey != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("apiKey", apiKey));
        if (text != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("text", text));
        if (sentences != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("sentences", sentences));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call sentimentValidateBeforeCall(String apiKey, String text, Integer sentences, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'apiKey' is set
        if (apiKey == null) {
            throw new ApiException("Missing the required parameter 'apiKey' when calling sentiment(Async)");
        }
        // verify the required parameter 'text' is set
        if (text == null) {
            throw new ApiException("Missing the required parameter 'text' when calling sentiment(Async)");
        }
        
        com.squareup.okhttp.Call call = sentimentCall(apiKey, text, sentences, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Vocabulary based sentiment detection
     * Compute the sentiment using a vocabulary based approach. The sentiment classification only works for English language. 
     * @param apiKey Your API key (required)
     * @param text The text that will be used to calculate sentiment. (required)
     * @param sentences Number of sentences on which to compute the sentiment. (optional, default to 10)
     * @return Sentiment
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public Sentiment sentiment(String apiKey, String text, Integer sentences) throws ApiException {
        ApiResponse<Sentiment> resp = sentimentWithHttpInfo(apiKey, text, sentences);
        return resp.getData();
    }

    /**
     * Vocabulary based sentiment detection
     * Compute the sentiment using a vocabulary based approach. The sentiment classification only works for English language. 
     * @param apiKey Your API key (required)
     * @param text The text that will be used to calculate sentiment. (required)
     * @param sentences Number of sentences on which to compute the sentiment. (optional, default to 10)
     * @return ApiResponse&lt;Sentiment&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Sentiment> sentimentWithHttpInfo(String apiKey, String text, Integer sentences) throws ApiException {
        com.squareup.okhttp.Call call = sentimentValidateBeforeCall(apiKey, text, sentences, null, null);
        Type localVarReturnType = new TypeToken<Sentiment>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Vocabulary based sentiment detection (asynchronously)
     * Compute the sentiment using a vocabulary based approach. The sentiment classification only works for English language. 
     * @param apiKey Your API key (required)
     * @param text The text that will be used to calculate sentiment. (required)
     * @param sentences Number of sentences on which to compute the sentiment. (optional, default to 10)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call sentimentAsync(String apiKey, String text, Integer sentences, final ApiCallback<Sentiment> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = sentimentValidateBeforeCall(apiKey, text, sentences, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<Sentiment>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for sentiment_0
     * @param apiKey Your API key (required)
     * @param text The text that will be used to calculate sentiment. (required)
     * @param sentences Number of sentences on which to compute the sentiment. (optional, default to 10)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call sentiment_0Call(String apiKey, String text, Integer sentences, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/sentimentRNN";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (apiKey != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("apiKey", apiKey));
        if (text != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("text", text));
        if (sentences != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("sentences", sentences));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call sentiment_0ValidateBeforeCall(String apiKey, String text, Integer sentences, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'apiKey' is set
        if (apiKey == null) {
            throw new ApiException("Missing the required parameter 'apiKey' when calling sentiment_0(Async)");
        }
        // verify the required parameter 'text' is set
        if (text == null) {
            throw new ApiException("Missing the required parameter 'text' when calling sentiment_0(Async)");
        }
        
        com.squareup.okhttp.Call call = sentiment_0Call(apiKey, text, sentences, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Neural networks based approach to sentiment detection
     * Compute the sentiment using a neural network model. The sentiment classification only works for English language. 
     * @param apiKey Your API key (required)
     * @param text The text that will be used to calculate sentiment. (required)
     * @param sentences Number of sentences on which to compute the sentiment. (optional, default to 10)
     * @return Sentiment
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public Sentiment sentiment_0(String apiKey, String text, Integer sentences) throws ApiException {
        ApiResponse<Sentiment> resp = sentiment_0WithHttpInfo(apiKey, text, sentences);
        return resp.getData();
    }

    /**
     * Neural networks based approach to sentiment detection
     * Compute the sentiment using a neural network model. The sentiment classification only works for English language. 
     * @param apiKey Your API key (required)
     * @param text The text that will be used to calculate sentiment. (required)
     * @param sentences Number of sentences on which to compute the sentiment. (optional, default to 10)
     * @return ApiResponse&lt;Sentiment&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Sentiment> sentiment_0WithHttpInfo(String apiKey, String text, Integer sentences) throws ApiException {
        com.squareup.okhttp.Call call = sentiment_0ValidateBeforeCall(apiKey, text, sentences, null, null);
        Type localVarReturnType = new TypeToken<Sentiment>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Neural networks based approach to sentiment detection (asynchronously)
     * Compute the sentiment using a neural network model. The sentiment classification only works for English language. 
     * @param apiKey Your API key (required)
     * @param text The text that will be used to calculate sentiment. (required)
     * @param sentences Number of sentences on which to compute the sentiment. (optional, default to 10)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call sentiment_0Async(String apiKey, String text, Integer sentences, final ApiCallback<Sentiment> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = sentiment_0ValidateBeforeCall(apiKey, text, sentences, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<Sentiment>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for trainTopicOnTwitter
     * @param apiKey Your API key (required)
     * @param twitterQuery string containing the content to search for. It can be a Twitter user account (using \&quot;@\&quot; prefix or user&#x27;s Twitter url), a hash tag (using \&quot;#\&quot; prefix) or a regular keyword. (required)
     * @param useTweetText Annotate and extract information from the content of the tweets. (optional, default to false)
     * @param maxTweets Maximum number of matching tweets to analyze. (optional, default to 2000)
     * @param normalization The way to normalize the concept weights (\&quot;none\&quot;, \&quot;linear\&quot;). (optional)
     * @param ignoreConceptTypes If you want to ignore certain concept types from the topic, you can specify them here. The available types to ignore are &#x60;person&#x60;, &#x60;org&#x60;, &#x60;loc&#x60;, or &#x60;wiki&#x60;.  (optional)
     * @param maxConcepts Maximum number of top concepts to store in the topic. (optional, default to 20)
     * @param maxCategories Maximum number of top categories to store in the topic. (optional, default to 10)
     * @param notifyEmailAddress The email address to which you would like us to send a notification email once the training of the topic is finished. (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call trainTopicOnTwitterCall(String apiKey, String twitterQuery, Boolean useTweetText, Integer maxTweets, String normalization, String ignoreConceptTypes, Integer maxConcepts, Integer maxCategories, String notifyEmailAddress, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/trainTopicOnTwitter";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (apiKey != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("apiKey", apiKey));
        if (twitterQuery != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("twitterQuery", twitterQuery));
        if (useTweetText != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("useTweetText", useTweetText));
        if (maxTweets != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("maxTweets", maxTweets));
        if (normalization != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("normalization", normalization));
        if (ignoreConceptTypes != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("ignoreConceptTypes", ignoreConceptTypes));
        if (maxConcepts != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("maxConcepts", maxConcepts));
        if (maxCategories != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("maxCategories", maxCategories));
        if (notifyEmailAddress != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("notifyEmailAddress", notifyEmailAddress));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call trainTopicOnTwitterValidateBeforeCall(String apiKey, String twitterQuery, Boolean useTweetText, Integer maxTweets, String normalization, String ignoreConceptTypes, Integer maxConcepts, Integer maxCategories, String notifyEmailAddress, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'apiKey' is set
        if (apiKey == null) {
            throw new ApiException("Missing the required parameter 'apiKey' when calling trainTopicOnTwitter(Async)");
        }
        // verify the required parameter 'twitterQuery' is set
        if (twitterQuery == null) {
            throw new ApiException("Missing the required parameter 'twitterQuery' when calling trainTopicOnTwitter(Async)");
        }
        
        com.squareup.okhttp.Call call = trainTopicOnTwitterCall(apiKey, twitterQuery, useTweetText, maxTweets, normalization, ignoreConceptTypes, maxConcepts, maxCategories, notifyEmailAddress, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Train a topic (concepts and categories) based on tweets matching your search filter
     * You can train a definition of a topic by analyzing the tweets that match a particular search filter. The collection of tweets that will be analyzed can be identified based on a Twitter username, a hashtag or a regular keyword. The chosen number of tweets matching the criteria will be identified and analyzed by identifying the concepts mentioned in them and the content will be categorizer. In addition to analyzing the content of the tweets, the articles linked in the tweets will also be analyzed and information will be extracted from them in the same way. The concepts and categories that will be found more commonly in the tweets will receive a higher weight in your final topic. Once the topic is trained, you can use the endpoint &#x60;/trainTopic&#x60; with &#x60;action&#x3D;getTrainedTopic&#x60; and your topic &#x60;uri&#x60; to retrieve the topic definition. 
     * @param apiKey Your API key (required)
     * @param twitterQuery string containing the content to search for. It can be a Twitter user account (using \&quot;@\&quot; prefix or user&#x27;s Twitter url), a hash tag (using \&quot;#\&quot; prefix) or a regular keyword. (required)
     * @param useTweetText Annotate and extract information from the content of the tweets. (optional, default to false)
     * @param maxTweets Maximum number of matching tweets to analyze. (optional, default to 2000)
     * @param normalization The way to normalize the concept weights (\&quot;none\&quot;, \&quot;linear\&quot;). (optional)
     * @param ignoreConceptTypes If you want to ignore certain concept types from the topic, you can specify them here. The available types to ignore are &#x60;person&#x60;, &#x60;org&#x60;, &#x60;loc&#x60;, or &#x60;wiki&#x60;.  (optional)
     * @param maxConcepts Maximum number of top concepts to store in the topic. (optional, default to 20)
     * @param maxCategories Maximum number of top categories to store in the topic. (optional, default to 10)
     * @param notifyEmailAddress The email address to which you would like us to send a notification email once the training of the topic is finished. (optional)
     * @return InlineResponse200
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public InlineResponse200 trainTopicOnTwitter(String apiKey, String twitterQuery, Boolean useTweetText, Integer maxTweets, String normalization, String ignoreConceptTypes, Integer maxConcepts, Integer maxCategories, String notifyEmailAddress) throws ApiException {
        ApiResponse<InlineResponse200> resp = trainTopicOnTwitterWithHttpInfo(apiKey, twitterQuery, useTweetText, maxTweets, normalization, ignoreConceptTypes, maxConcepts, maxCategories, notifyEmailAddress);
        return resp.getData();
    }

    /**
     * Train a topic (concepts and categories) based on tweets matching your search filter
     * You can train a definition of a topic by analyzing the tweets that match a particular search filter. The collection of tweets that will be analyzed can be identified based on a Twitter username, a hashtag or a regular keyword. The chosen number of tweets matching the criteria will be identified and analyzed by identifying the concepts mentioned in them and the content will be categorizer. In addition to analyzing the content of the tweets, the articles linked in the tweets will also be analyzed and information will be extracted from them in the same way. The concepts and categories that will be found more commonly in the tweets will receive a higher weight in your final topic. Once the topic is trained, you can use the endpoint &#x60;/trainTopic&#x60; with &#x60;action&#x3D;getTrainedTopic&#x60; and your topic &#x60;uri&#x60; to retrieve the topic definition. 
     * @param apiKey Your API key (required)
     * @param twitterQuery string containing the content to search for. It can be a Twitter user account (using \&quot;@\&quot; prefix or user&#x27;s Twitter url), a hash tag (using \&quot;#\&quot; prefix) or a regular keyword. (required)
     * @param useTweetText Annotate and extract information from the content of the tweets. (optional, default to false)
     * @param maxTweets Maximum number of matching tweets to analyze. (optional, default to 2000)
     * @param normalization The way to normalize the concept weights (\&quot;none\&quot;, \&quot;linear\&quot;). (optional)
     * @param ignoreConceptTypes If you want to ignore certain concept types from the topic, you can specify them here. The available types to ignore are &#x60;person&#x60;, &#x60;org&#x60;, &#x60;loc&#x60;, or &#x60;wiki&#x60;.  (optional)
     * @param maxConcepts Maximum number of top concepts to store in the topic. (optional, default to 20)
     * @param maxCategories Maximum number of top categories to store in the topic. (optional, default to 10)
     * @param notifyEmailAddress The email address to which you would like us to send a notification email once the training of the topic is finished. (optional)
     * @return ApiResponse&lt;InlineResponse200&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<InlineResponse200> trainTopicOnTwitterWithHttpInfo(String apiKey, String twitterQuery, Boolean useTweetText, Integer maxTweets, String normalization, String ignoreConceptTypes, Integer maxConcepts, Integer maxCategories, String notifyEmailAddress) throws ApiException {
        com.squareup.okhttp.Call call = trainTopicOnTwitterValidateBeforeCall(apiKey, twitterQuery, useTweetText, maxTweets, normalization, ignoreConceptTypes, maxConcepts, maxCategories, notifyEmailAddress, null, null);
        Type localVarReturnType = new TypeToken<InlineResponse200>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Train a topic (concepts and categories) based on tweets matching your search filter (asynchronously)
     * You can train a definition of a topic by analyzing the tweets that match a particular search filter. The collection of tweets that will be analyzed can be identified based on a Twitter username, a hashtag or a regular keyword. The chosen number of tweets matching the criteria will be identified and analyzed by identifying the concepts mentioned in them and the content will be categorizer. In addition to analyzing the content of the tweets, the articles linked in the tweets will also be analyzed and information will be extracted from them in the same way. The concepts and categories that will be found more commonly in the tweets will receive a higher weight in your final topic. Once the topic is trained, you can use the endpoint &#x60;/trainTopic&#x60; with &#x60;action&#x3D;getTrainedTopic&#x60; and your topic &#x60;uri&#x60; to retrieve the topic definition. 
     * @param apiKey Your API key (required)
     * @param twitterQuery string containing the content to search for. It can be a Twitter user account (using \&quot;@\&quot; prefix or user&#x27;s Twitter url), a hash tag (using \&quot;#\&quot; prefix) or a regular keyword. (required)
     * @param useTweetText Annotate and extract information from the content of the tweets. (optional, default to false)
     * @param maxTweets Maximum number of matching tweets to analyze. (optional, default to 2000)
     * @param normalization The way to normalize the concept weights (\&quot;none\&quot;, \&quot;linear\&quot;). (optional)
     * @param ignoreConceptTypes If you want to ignore certain concept types from the topic, you can specify them here. The available types to ignore are &#x60;person&#x60;, &#x60;org&#x60;, &#x60;loc&#x60;, or &#x60;wiki&#x60;.  (optional)
     * @param maxConcepts Maximum number of top concepts to store in the topic. (optional, default to 20)
     * @param maxCategories Maximum number of top categories to store in the topic. (optional, default to 10)
     * @param notifyEmailAddress The email address to which you would like us to send a notification email once the training of the topic is finished. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call trainTopicOnTwitterAsync(String apiKey, String twitterQuery, Boolean useTweetText, Integer maxTweets, String normalization, String ignoreConceptTypes, Integer maxConcepts, Integer maxCategories, String notifyEmailAddress, final ApiCallback<InlineResponse200> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = trainTopicOnTwitterValidateBeforeCall(apiKey, twitterQuery, useTweetText, maxTweets, normalization, ignoreConceptTypes, maxConcepts, maxCategories, notifyEmailAddress, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<InlineResponse200>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for trainTopicOnTwitter_0
     * @param apiKey Your API key (required)
     * @param action string containing the content to search for. It can be a Twitter user account (using \&quot;@\&quot; prefix or user&#x27;s Twitter url), a hash tag (using \&quot;#\&quot; prefix) or a regular keyword. (required)
     * @param name name of the topic to create. Relevant for action &#x60;createTopic&#x60;. (optional)
     * @param uri uri of the topic to update or retrieve information about. Relevant for actions: &#x60;addDocument&#x60;, &#x60;finishTraining&#x60;, &#x60;getTrainedTopic&#x60;. (optional)
     * @param text the content of the document to use for updating the topic definition. The document will be annotated and categorized and the concepts and categories will be used to update the topic. (optional)
     * @param maxConcepts The maximum number of concepts to use in the final topic. Relevant for action &#x60;finishTraining&#x60;. (optional, default to 20)
     * @param maxCategories The maximum number of categories to use in the final topic. Relevant for action &#x60;finishTraining&#x60;. (optional, default to 10)
     * @param idfNormalization Should the concepts be normalized to punish the concepts that are more commonly mentioned in general news? (optional, default to true)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call trainTopicOnTwitter_0Call(String apiKey, String action, String name, String uri, String text, Integer maxConcepts, Integer maxCategories, Boolean idfNormalization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/trainTopic";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (apiKey != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("apiKey", apiKey));
        if (action != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("action", action));
        if (name != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("name", name));
        if (uri != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("uri", uri));
        if (text != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("text", text));
        if (maxConcepts != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("maxConcepts", maxConcepts));
        if (maxCategories != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("maxCategories", maxCategories));
        if (idfNormalization != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("idfNormalization", idfNormalization));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call trainTopicOnTwitter_0ValidateBeforeCall(String apiKey, String action, String name, String uri, String text, Integer maxConcepts, Integer maxCategories, Boolean idfNormalization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'apiKey' is set
        if (apiKey == null) {
            throw new ApiException("Missing the required parameter 'apiKey' when calling trainTopicOnTwitter_0(Async)");
        }
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling trainTopicOnTwitter_0(Async)");
        }
        
        com.squareup.okhttp.Call call = trainTopicOnTwitter_0Call(apiKey, action, name, uri, text, maxConcepts, maxCategories, idfNormalization, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Train a topic (concepts and categories) using your own documents
     * The API endpoint can be used to train a definition of a topic by analyzing several documents that you can provide. The documents will be annotated and categorized and the topic will be then defined by identifying commonly mentioned concepts and categories. The concepts and categories that will be found more commonly in your documents will receive a higher weight in your topic.  Training of the topic can be done in several steps, which are triggered based on the specified &#x60;action&#x60; parameter. The initial step has to be a call with &#x60;action &#x3D; createTopic&#x60;. In the response you will receive a &#x60;uri&#x60; parameter that has to be specified in the followup calls.  In order to add documents to the topic specify &#x60;action &#x3D; addDocument&#x60;. The topic will be finished once you call the endpoint with &#x60;action &#x3D; finishTraining&#x60;. At that time, the returned information will also include the &#x60;topic&#x60; property containing the trained topic.  If you wish to retrieve the topic at some later point, you can retrieve it again by using &#x60;action &#x3D; getTrainedTopic&#x60;. 
     * @param apiKey Your API key (required)
     * @param action string containing the content to search for. It can be a Twitter user account (using \&quot;@\&quot; prefix or user&#x27;s Twitter url), a hash tag (using \&quot;#\&quot; prefix) or a regular keyword. (required)
     * @param name name of the topic to create. Relevant for action &#x60;createTopic&#x60;. (optional)
     * @param uri uri of the topic to update or retrieve information about. Relevant for actions: &#x60;addDocument&#x60;, &#x60;finishTraining&#x60;, &#x60;getTrainedTopic&#x60;. (optional)
     * @param text the content of the document to use for updating the topic definition. The document will be annotated and categorized and the concepts and categories will be used to update the topic. (optional)
     * @param maxConcepts The maximum number of concepts to use in the final topic. Relevant for action &#x60;finishTraining&#x60;. (optional, default to 20)
     * @param maxCategories The maximum number of categories to use in the final topic. Relevant for action &#x60;finishTraining&#x60;. (optional, default to 10)
     * @param idfNormalization Should the concepts be normalized to punish the concepts that are more commonly mentioned in general news? (optional, default to true)
     * @return InlineResponse2001
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public InlineResponse2001 trainTopicOnTwitter_0(String apiKey, String action, String name, String uri, String text, Integer maxConcepts, Integer maxCategories, Boolean idfNormalization) throws ApiException {
        ApiResponse<InlineResponse2001> resp = trainTopicOnTwitter_0WithHttpInfo(apiKey, action, name, uri, text, maxConcepts, maxCategories, idfNormalization);
        return resp.getData();
    }

    /**
     * Train a topic (concepts and categories) using your own documents
     * The API endpoint can be used to train a definition of a topic by analyzing several documents that you can provide. The documents will be annotated and categorized and the topic will be then defined by identifying commonly mentioned concepts and categories. The concepts and categories that will be found more commonly in your documents will receive a higher weight in your topic.  Training of the topic can be done in several steps, which are triggered based on the specified &#x60;action&#x60; parameter. The initial step has to be a call with &#x60;action &#x3D; createTopic&#x60;. In the response you will receive a &#x60;uri&#x60; parameter that has to be specified in the followup calls.  In order to add documents to the topic specify &#x60;action &#x3D; addDocument&#x60;. The topic will be finished once you call the endpoint with &#x60;action &#x3D; finishTraining&#x60;. At that time, the returned information will also include the &#x60;topic&#x60; property containing the trained topic.  If you wish to retrieve the topic at some later point, you can retrieve it again by using &#x60;action &#x3D; getTrainedTopic&#x60;. 
     * @param apiKey Your API key (required)
     * @param action string containing the content to search for. It can be a Twitter user account (using \&quot;@\&quot; prefix or user&#x27;s Twitter url), a hash tag (using \&quot;#\&quot; prefix) or a regular keyword. (required)
     * @param name name of the topic to create. Relevant for action &#x60;createTopic&#x60;. (optional)
     * @param uri uri of the topic to update or retrieve information about. Relevant for actions: &#x60;addDocument&#x60;, &#x60;finishTraining&#x60;, &#x60;getTrainedTopic&#x60;. (optional)
     * @param text the content of the document to use for updating the topic definition. The document will be annotated and categorized and the concepts and categories will be used to update the topic. (optional)
     * @param maxConcepts The maximum number of concepts to use in the final topic. Relevant for action &#x60;finishTraining&#x60;. (optional, default to 20)
     * @param maxCategories The maximum number of categories to use in the final topic. Relevant for action &#x60;finishTraining&#x60;. (optional, default to 10)
     * @param idfNormalization Should the concepts be normalized to punish the concepts that are more commonly mentioned in general news? (optional, default to true)
     * @return ApiResponse&lt;InlineResponse2001&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<InlineResponse2001> trainTopicOnTwitter_0WithHttpInfo(String apiKey, String action, String name, String uri, String text, Integer maxConcepts, Integer maxCategories, Boolean idfNormalization) throws ApiException {
        com.squareup.okhttp.Call call = trainTopicOnTwitter_0ValidateBeforeCall(apiKey, action, name, uri, text, maxConcepts, maxCategories, idfNormalization, null, null);
        Type localVarReturnType = new TypeToken<InlineResponse2001>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Train a topic (concepts and categories) using your own documents (asynchronously)
     * The API endpoint can be used to train a definition of a topic by analyzing several documents that you can provide. The documents will be annotated and categorized and the topic will be then defined by identifying commonly mentioned concepts and categories. The concepts and categories that will be found more commonly in your documents will receive a higher weight in your topic.  Training of the topic can be done in several steps, which are triggered based on the specified &#x60;action&#x60; parameter. The initial step has to be a call with &#x60;action &#x3D; createTopic&#x60;. In the response you will receive a &#x60;uri&#x60; parameter that has to be specified in the followup calls.  In order to add documents to the topic specify &#x60;action &#x3D; addDocument&#x60;. The topic will be finished once you call the endpoint with &#x60;action &#x3D; finishTraining&#x60;. At that time, the returned information will also include the &#x60;topic&#x60; property containing the trained topic.  If you wish to retrieve the topic at some later point, you can retrieve it again by using &#x60;action &#x3D; getTrainedTopic&#x60;. 
     * @param apiKey Your API key (required)
     * @param action string containing the content to search for. It can be a Twitter user account (using \&quot;@\&quot; prefix or user&#x27;s Twitter url), a hash tag (using \&quot;#\&quot; prefix) or a regular keyword. (required)
     * @param name name of the topic to create. Relevant for action &#x60;createTopic&#x60;. (optional)
     * @param uri uri of the topic to update or retrieve information about. Relevant for actions: &#x60;addDocument&#x60;, &#x60;finishTraining&#x60;, &#x60;getTrainedTopic&#x60;. (optional)
     * @param text the content of the document to use for updating the topic definition. The document will be annotated and categorized and the concepts and categories will be used to update the topic. (optional)
     * @param maxConcepts The maximum number of concepts to use in the final topic. Relevant for action &#x60;finishTraining&#x60;. (optional, default to 20)
     * @param maxCategories The maximum number of categories to use in the final topic. Relevant for action &#x60;finishTraining&#x60;. (optional, default to 10)
     * @param idfNormalization Should the concepts be normalized to punish the concepts that are more commonly mentioned in general news? (optional, default to true)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call trainTopicOnTwitter_0Async(String apiKey, String action, String name, String uri, String text, Integer maxConcepts, Integer maxCategories, Boolean idfNormalization, final ApiCallback<InlineResponse2001> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = trainTopicOnTwitter_0ValidateBeforeCall(apiKey, action, name, uri, text, maxConcepts, maxCategories, idfNormalization, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<InlineResponse2001>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
}
